---
layout: post
title: Redis Src
tags: redis redis-internal
---


## Redis Overview

<!-- more -->

### Advantages of Redis

- Supports numerous data types
- Supports persistence
- Supports "events"
- Supports multi-machine and cluster distribution
- Supports publish and subscribe
- Supports transactions
- Supports embedded Lua scripts

### 5 Data Types

Redis supports 5 data types: string objects, list objects, hash objects, set objects, and sorted set objects.

```
127.0.0.1:6379> set name "xuwenzhi"
OK
127.0.0.1:6379> get name
"xuwenzhi"
127.0.0.1:6379> rpush numbers 1 2 3 4 5
(integer) 5
127.0.0.1:6379>
```

### Persistence

- RDB Persistence
- AOF Persistence

### Events

- File Events: Dynamically respond to client requests
- Time Events: Used for routine maintenance and management operations to ensure Redis runs normally, including some scheduled operations

### Multi-machine and Cluster Distribution

- Replication: Data communication between servers
- Sentinel: Methods for monitoring server running status and failover
- Cluster: Communication methods between nodes

### Publish and Subscribe

- PUBLISH
- SUBSCRIBE
- PUBSUB


## SDS

All strings in Redis use a structure called SDS (Simple Dynamic String). For example, key-value pairs in K-V, or strings in complex objects within V, all use SDS.

```c
sds.h/sdshdr
/*
 * Structure for storing string objects
 */
struct sdshdr {
    // Length of occupied space in buf
    int len;
    // Length of remaining available space in buf
    int free;
    // Data space
    char buf[];
};
```

So the question is: Why doesn't Redis directly use C language's string manipulation method, but instead wraps it with SDS?

### Advantages of SDS

- When querying a character in a string, no need to traverse like in C; complexity is O(1), and getting string length is very fast
- Ensures no buffer overflow. For example, during modification operations, you can immediately know through free whether there's enough remaining space to perform the modification without overflow
- After adding SDS, memory reallocation operations caused by frequent string concatenation can be guaranteed, and through the transparency of free, Redis's space pre-allocation and lazy release features can be implemented
- Binary safe, ensuring SDS can handle binary data

### Space Pre-allocation: When Modifying SDS

- When length is less than 1MB: if current len is 13, the same 13-length size is also allocated for free. At this time, buf length is 13+13+1
- When length is greater than 1MB: if current len is 30MB, 1MB is allocated for free. At this time, buf length is 30M+1M+1byte (as for why 1MB is allocated for free, see #define SDS_MAX_PREALLOC (1024*1024))


## Redis Object

The Redis object system is not something new but is an integrated object system based on string objects, list objects, hash objects, set objects, and sorted set objects. For example, when creating a simple string object, both the key and value in the key-value pair are Redis objects.

```c
//redis.h/redisObject
typedef struct redisObject {
    // Type
    unsigned type:4;
    // Encoding
    unsigned encoding:4;
    // Last access time of object
    unsigned lru:REDIS_LRU_BITS; /* lru time (relative to server.lruclock) */
    // Reference count
    int refcount;
    // Pointer to actual value
    void *ptr;
} robj;
```

type: Object type. Possible values are REDIS_STRING, REDIS_LIST, REDIS_HASH, REDIS_SET, and REDIS_ZSET, etc. You can use the TYPE command to get the object type.

```
127.0.0.1:6379> get name
"xuwenzhi"
127.0.0.1:6379> TYPE name
string
127.0.0.1:6379> RPUSH numbers 1 2 3
(integer) 8
127.0.0.1:6379> TYPE numbers
list
127.0.0.1:6379> HMSET profile name Tome age 25 career Programmer
OK
127.0.0.1:6379> TYPE profile
hash
127.0.0.1:6379> SADD fruits apple banana cherry
(integer) 3
127.0.0.1:6379> TYPE fruits
set
127.0.0.1:6379> ZADD price 8.5 apple 5.0 banana 6.0 cherry
(integer) 3
127.0.0.1:6379> TYPE price
zset
127.0.0.1:6379>
```

![http://img.xuwenzhi.com/redisbianmachangliang.jpg](http://img.xuwenzhi.com/redisbianmachangliang.jpg)

ptr: Points to the underlying data structure implementation of the object. Since Redis has many different underlying implementations, the encoding member is also needed to specify. The following diagram shows the possible values and explanations for encoding.

![http://img.xuwenzhi.com/redistypeencoding.jpg](http://img.xuwenzhi.com/redistypeencoding.jpg)

At this point, the Redis object structure has type and encoding members to distinguish different objects. When these two members are combined, even more different objects can be composed, because each type of object uses at least two different encodings.


# ListNode

Linked lists are used extensively in Redis. For example, one of the underlying implementations of list keys is linked lists. Additionally, publish/subscribe, slow queries, monitors, and multiple client state information are stored using linked lists.

Redis Linked List Implementation

```c
adlist.h/listNode
/*
 * Doubly linked list node
 */
typedef struct listNode {
    // Previous node
    struct listNode *prev;
    // Next node
    struct listNode *next;
    // Node value
    void *value;
} listNode;
```

Although listNode itself can implement doubly linked list functionality, Redis wraps listNode when using linked lists:

```
/*
 * Doubly linked list structure
 */
typedef struct list {
    // Head node
    listNode *head;
    // Tail node
    listNode *tail;
    // Node value copy function
    void *(*dup)(void *ptr);
    // Node value release function
    void (*free)(void *ptr);
    // Node value comparison function
    int (*match)(void *ptr, void *key);
    // Number of nodes in the list
    unsigned long len;
} list;
```

### Characteristics

- Doubly-ended: Getting head and tail are both O(1)
- Acyclic: Both head and tail nodes point to NULL
- Getting list length only requires list.len
- Polymorphic: List nodes use (void*) to store node values, ensuring the list can store different types of values

## Integer Set

When a set contains only integer value elements and the quantity is small, Redis uses an integer set as the underlying implementation of set keys.

```c
//intset.h/intset
typedef struct intset {
    // Encoding method
    uint32_t encoding;
    // Number of elements in the set
    uint32_t length;
    // Array for storing elements
    int8_t contents[];
} intset;
```

contents[]: Although the type of content is defined as int8_t, the actual type of contents[] is determined by encoding. And the numbers in contents[] are arranged from smallest to largest.

### Integer Set Upgrade

When adding numbers to contents[] (< the smallest number || > the largest number), an upgrade operation needs to be performed on the integer set. The upgrade operation includes not only expanding the length of contents[] but also changing the encoding type.

### Steps for Integer Set Upgrade

- Expand the underlying memory space of the integer set according to the type of the new number, and allocate space for the new data
- Convert all original integers in the set to the same type as the new number, maintaining the original smallest-to-largest order
- Add the new number to the integer set

### Integer Set Downgrade

Not supported.

### Advantages of Integer Set

- Store different types of integers flexibly
- Save memory space


## Map

Dictionaries are used extensively in Redis. For example, the underlying implementation of adding, deleting, modifying, and querying in Redis database is achieved through dictionaries.

```
127.0.0.1:6379> set name "xuwenzhi"
OK
```

For example, the mapping of the key-value pair "name" and "xuwenzhi" in this example is implemented through a dictionary.

### Dictionary Implementation

The underlying implementation of Redis dictionary uses a hash table.

```c
dict.h/dictht
/*
 * Hash table
 * Each dictionary uses two hash tables for progressive rehash.
 */
typedef struct dictht {
    // Hash table array
    dictEntry **table;
    // Hash table size
    unsigned long size;
    // Hash table size mask for calculating index values
    // Always equals size - 1
    unsigned long sizemask;
    // Number of existing nodes in this hash table
    unsigned long used;
} dictht;
```

Looking at the table, its type is a dictEntry.

```c
dict.h/dictEntry
/*
 * Hash table node
 */
typedef struct dictEntry {
    // Key
    void *key;
    // Value
    union {
        void *val;
        uint64_t u64;
        int64_t s64;
    } v;
    // Pointer to next hash table node, forming a linked list
    struct dictEntry *next;
} dictEntry;
```

Where key is the dictionary key, and v is the dictionary value.

Dictionary Structure

```c
dict.h/dict
/*
 * Dictionary
 */
typedef struct dict {
    // Type-specific functions
    dictType *type;
    // Private data
    void *privdata;
    // Hash table
    dictht ht[2];
    // Rehash index
    // When rehash is not in progress, value is -1
    int rehashidx; /* rehashing not in progress if rehashidx == -1 */
    // Number of safe iterators currently running
    int iterators; /* number of iterators currently running */
} dict;
```

type: Of dictType type, indicates the dictionary type. Redis sets different dictionary operation functions for different types of dictionaries. privdata stores data passed to different operation functions.

ht: Points to a dictht hash table. Size is 2; ht[0] is generally used, ht[1] is backup, mainly for rehash.

rehashidx: Rehash status. When -1, indicates no rehash is currently in progress.

```c
dict.h/dictType
/*
 * Dictionary type-specific functions
 */
typedef struct dictType {
    // Function to calculate hash value
    unsigned int (*hashFunction)(const void *key);
    // Function to copy key
    void *(*keyDup)(void *privdata, const void *key);
    // Function to copy value
    void *(*valDup)(void *privdata, const void *obj);
    // Function to compare keys
    int (*keyCompare)(void *privdata, const void *key1, const void *key2);
    // Function to destroy key
    void (*keyDestructor)(void *privdata, void *key);
    // Function to destroy value
    void (*valDestructor)(void *privdata, void *obj);
} dictType;
```

Hash Algorithm

Calculating hash value: Determine which hash table dictEntry

```c
// Calculate hash value of key
hash = dict->type->hashFunction(key);
```

Calculating index value: Determine which index in dictEntry

```c
index = hash & dict->ht[x].sizemask;
```

x is 0 or 1 depending on the situation.

### Resolving Hash Collisions

Redis's hash collision resolution method is chaining. When a new key conflicts with an existing key, it's linked through the dictEntry.next pointer on top of the original key.


### Rehash

Of course, the original collision resolution scheme may cause the dictEntry chain to become longer and longer. If it exceeds the hash table's load factor, then Rehash comes into play, meaning ht[1] needs to come on stage.

```
load factor = ht[0].used / ht[0].size
```

### How to Perform Rehash

- Allocate space for ht[1]: How much to allocate depends on the size of ht[0].used
- Recalculate hash values for all key-value pairs stored in ht[0] and save them in ht[1]
- Release ht[0], set ht[1] as ht[0], then regenerate ht[1] (ht[1] is NULL at this point), preparing for the next rehash

### Hash Table Shrinking and Expansion

##### When to Expand?

- When the server is not currently executing BGSAVE or BGREWRITEAOF, and load factor > 1
- When the server is currently executing BGSAVE or BGREWRITEAOF, and load factor > 5

##### When to Shrink?

- When the hash table's load factor < 0.1, automatic shrinking occurs

##### Rehash is Progressive

This means during the Rehash process, ht[0] doesn't transfer to ht[1] all at once, but progressively.

During the Rehash process, rehashidx plays an important role. The detailed steps are:

- Allocate space for ht[1]
- Set rehashidx to 0, indicating rehash has started
- During the progressive rehash process, rehashidx is updated to the current key value being rehashed
- Before you know it, rehashidx becomes -1, indicating rehash is complete



## Skip List

A skip list is an ordered data structure that achieves fast access by maintaining multiple pointers to other nodes in each node.

Time Complexity: Average O(logN), Worst O(N)

![http://img.xuwenzhi.com/tiaoyuebiao.jpg](http://img.xuwenzhi.com/tiaoyuebiao.jpg)

In Redis, skip lists are mainly used to implement sorted set keys and as internal data structures in cluster nodes.

The first node in the diagram contains L(1->32), marked by zskiplistNode.level[0-32]. The horizontal direction L1->L1->L1... is implemented through the forward pointer in zskiplistNode.

Level: The concept of level here is that L1->L1->L1 in the diagram represents one level, L2->L2->L2->L2 represents another level.

Span: For example, L1->L1 in the diagram are connected, span is 1; L5->L5 span is 3.

Length: As in the diagram, the longest L1->L1->L1->L1, the longest length is 3 (ignoring the header node).

BW (backward): Pointer to the previous node.

score: Scores of each node, like 1.0, 2.0, 3.0, etc. Nodes are arranged from smallest to largest score.

zskiplistNode is mainly used to store skip list nodes.

```c
//redis.h/zskiplistNode
/*
 * Skip list node
 */
typedef struct zskiplistNode {
    // Member object, visible as a redis object
    robj *obj;
    // Score
    double score;
    // Backward pointer
    struct zskiplistNode *backward;
    // Level
    struct zskiplistLevel {
        // Forward pointer
        struct zskiplistNode *forward;
        // Span
        unsigned int span;
    } level[];
} zskiplistNode;
```

zskiplist mainly records information about skip list nodes

```c
//redis.h/zskiplist
/*
 * Skip list
 */
typedef struct zskiplist {
    // Header and tail nodes
    struct zskiplistNode *header, *tail;
    // Number of nodes in the table
    unsigned long length;
    // Level count of the node with most levels
    int level;
} zskiplist;
```



## redisServer

### Databases in the Server

All database information in Redis is stored in the redis.h/redisServer structure. Each database node is defined by the redis.h/redisDb structure.

```c
//redis.h/redisDb
typedef struct redisDb {
    // Database key space, stores all key-value pairs in the database
    dict *dict;                 /* The keyspace for this DB */
    // Key expiration times, dictionary key is the key, dictionary value is expiration time UNIX timestamp
    dict *expires;              /* Timeout of keys with a timeout set */
    // Keys currently in blocking state
    dict *blocking_keys;        /* Keys with clients waiting for data (BLPOP) */
    // Keys that can unblock
    dict *ready_keys;           /* Blocked keys that received a PUSH */
    // Keys being watched by WATCH command
    dict *watched_keys;         /* WATCHED keys for MULTI/EXEC CAS */
    struct evictionPoolEntry *eviction_pool;    /* Eviction pool of keys */
    // Database number
    int id;                     /* Database ID */
    // Average TTL of database keys, statistical information
    long long avg_ttl;          /* Average TTL, just for stats */
} redisDb;
```

When the server starts, Redis initializes the number of databases according to the dbnum quantity defined in redis.h/redisServer. The default is 16 databases.

```c
/* Static server configuration */
// ...
#define REDIS_DEFAULT_DBNUM     16  /* Default number of databases */
// ...
//redis.h/redisServer
struct redisServer {
    redisDb *db;
    int dbnum;
}
```

Switching Databases

Redis uses database 0 by default. You can also switch databases using SELECT n.

```
127.0.0.1:6379> SELECT 1
OK
127.0.0.1:6379[1]> get name
(nil)
127.0.0.1:6379[1]> select 0
OK
127.0.0.1:6379> get name
"xuwenzhi"
```

SELECT Implementation Principle

Since Redis defines a client structure that stores a pointer to the currently used database node, switching databases with SELECT only requires changing the pointer.

```c
//redis.h/redisClient
typedef struct redisClient {
    //...
    // ID (number) of the currently used database
    int dictid;
    //...
}
```

### Database Key Space

Redis stores all key-value pairs in the database in the redis.h/redisDb.dict dictionary, called the "key space." Keys in the key space are string objects, and values can be any Redis object (string, list, hash, set, and sorted set).

So operations like SET, GET, DEL are actually just adding, deleting, modifying, and querying the database.

### Other Database Operation Commands

- FLUSHDB: As the name suggests, clears the database by deleting the key space
- RANDOMKEY: Randomly returns a key from the key space
- DBSIZE: Returns the number of key-value pairs in the key space
- EXISTS: Whether a key exists
- RENAME: Rename a key
- KEYS: Return all keys
- EXPIRE: Set expiration time for a key
- TTL: Return expiration time of a key

```bash
127.0.0.1:6379> RANDOMKEY
"profile"
127.0.0.1:6379> DBSIZE
(integer) 5
127.0.0.1:6379> EXISTS name
(integer) 1
127.0.0.1:6379> EXISTS name1
(integer) 0
127.0.0.1:6379> KEYS *
1) "fruits"
2) "profile"
3) "price"
4) "numbers"
5) "name"
127.0.0.1:6379>
```


### Common Expired Key Deletion Strategies

- Timed Deletion: Each key has a dedicated timer that deletes it immediately upon expiration. Building timers for all keys consumes too much CPU resources. Not feasible.
- Lazy Deletion: No checking is done. When a GET operation discovers a key has expired, it's deleted. Not memory-friendly because long-unused key-value pairs may remain in memory for a long time, potentially causing memory leaks.
- Periodic Deletion: Periodically check the key space and delete expired keys. The difficulty lies in determining the periodic interval, which may not guarantee data consistency.

### Redis Expired Key Deletion Strategy

- Lazy Deletion + Periodic Deletion

##### Lazy Deletion

```c
//db.c/expireIfNeeded
/*
 * Check if key has expired, if so, delete it from the database.
 *
 * Returns 0 if key has no expiration time, or key has not expired.
 *
 * Returns 1 if key was deleted due to expiration.
 */
int expireIfNeeded(redisDb *db, robj *key) {
    // Get key expiration time
    mstime_t when = getExpire(db,key);
    mstime_t now;
    // No expiration time
    if (when < 0) return 0; /* No expire for this key */
    /* Don't expire anything while loading. It will be done later. */
    // If server is loading, don't perform any expiration check
    if (server.loading) return 0;
    /* If we are in the context of a Lua script, we claim that time is
     * blocked to when the Lua script started. This way a key can expire
     * only the first time it is accessed and not in the middle of the
     * script execution, making propagation to slaves / AOF consistent.
     * See issue #1525 on Github for more information. */
    now = server.lua_caller ? server.lua_time_start : mstime();
    /* If we are running in the context of a slave, return ASAP:
     * the slave key expiration is controlled by the master that will
     * send us synthesized DEL operations for expired keys.
     *
     * Still we try to return the right information to the caller,
     * that is, 0 if we think the key should be still valid, 1 if
     * we think the key is expired at this time. */
    // When server is running in replication mode
    // Slave nodes don't actively delete keys
    // They only return logically correct return values
    // Actual deletion waits for DELETE command from master
    // To ensure data synchronization
    if (server.masterhost != NULL) return now > when;
    // Running here means key has expiration time and server is master
    /* Return when this key has not expired */
    // If not expired, return 0
    if (now <= when) return 0;
    /* Delete the key */
    server.stat_expiredkeys++;
    // Propagate expiration info to AOF and slave nodes
    propagateExpire(db,key);
    // Send event notification
    notifyKeyspaceEvent(REDIS_NOTIFY_EXPIRED,
        "expired",key,db->id);
    // Delete expired key from database
    return dbDelete(db,key);
}
```

##### Periodic Deletion

Redis's server periodic operation redis.c/serverCron calls activeExpireCycle. Within a specified time, it iterates through various databases in the server multiple times, randomly checking a portion of keys from the expires dictionary of each database.

```c
void activeExpireCycle(int type) {
    /* This function has some global state in order to continue the work
     * incrementally across calls. */
    // Static variables for accumulating data across consecutive executions
    static unsigned int current_db = 0; /* Last DB tested. */
    static int timelimit_exit = 0;      /* Time limit hit in previous call? */
    static long long last_fast_cycle = 0; /* When last fast cycle ran. */
    unsigned int j, iteration = 0;
    // Default number of databases to process each time
    unsigned int dbs_per_call = REDIS_DBCRON_DBS_PER_CALL;
    // Function start time
    long long start = ustime(), timelimit;
    // Fast mode
    if (type == ACTIVE_EXPIRE_CYCLE_FAST) {
        /* Don't start a fast cycle if the previous cycle did not exited
         * for time limt. Also don't repeat a fast cycle for the same period
         * as the fast cycle total duration itself. */
        // If last function didn't trigger timelimit_exit, don't process
        if (!timelimit_exit) return;
        // If not enough time since last execution, don't process
        if (start < last_fast_cycle + ACTIVE_EXPIRE_CYCLE_FAST_DURATION*2) return;
        // Running here means executing fast processing, record current time
        last_fast_cycle = start;
    }
    /* We usually should test REDIS_DBCRON_DBS_PER_CALL per iteration, with
     * two exceptions:
     *
     * Normally, function only processes REDIS_DBCRON_DBS_PER_CALL databases,
     * except:
     *
     * 1) Don't test more DBs than we have.
     *    Current number of databases is less than REDIS_DBCRON_DBS_PER_CALL
     * 2) If last time we hit the time limit, we want to scan all DBs
     * in this iteration, as there is work to do in some DB and we don't want
     * expired keys to use memory for too much time.
     *     If last processing hit time limit, need to scan all databases,
     *     to avoid too many expired keys taking up space
     */
    if (dbs_per_call > server.dbnum || timelimit_exit)
        dbs_per_call = server.dbnum;
    /* We can use at max ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC percentage of CPU time
     * per iteration. Since this function gets called with a frequency of
     * server.hz times per second, the following is the max amount of
     * microseconds we can spend in this function. */
    // Function processing microsecond time limit
    // ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC defaults to 25, meaning 25% CPU time
    timelimit = 1000000*ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC/server.hz/100;
    timelimit_exit = 0;
    if (timelimit <= 0) timelimit = 1;
    // If running in fast mode
    // Can only run for at most FAST_DURATION microseconds
    // Default value is 1000 (microseconds)
    if (type == ACTIVE_EXPIRE_CYCLE_FAST)
        timelimit = ACTIVE_EXPIRE_CYCLE_FAST_DURATION; /* in microseconds. */
    // Iterate through databases
    for (j = 0; j < dbs_per_call; j++) {
        int expired;
        // Point to database to process
        redisDb *db = server.db+(current_db % server.dbnum);
        /* Increment the DB now so we are sure if we run out of time
         * in the current DB we'll restart from the next. This allows to
         * distribute the time evenly across DBs. */
        // Increment DB counter; if timeout in do loop
        // Next time will start from next DB
        current_db++;
        /* Continue to expire if at the end of the cycle more than 25%
         * of the keys were expired. */
        do {
            unsigned long num, slots;
            long long now, ttl_sum;
            int ttl_samples;
            /* If there is nothing to expire try next DB ASAP. */
            // Get number of keys with expiration time in database
            // If count is 0, skip this database
            if ((num = dictSize(db->expires)) == 0) {
                db->avg_ttl = 0;
                break;
            }
            // Get number of key-value pairs in database
            slots = dictSlots(db->expires);
            // Current time
            now = mstime();
            /* When there are less than 1% filled slots getting random
             * keys is expensive, so stop here waiting for better times...
             * The dictionary will be resized asap. */
            // This database has less than 1% usage, too expensive to scan (most will MISS)
            // Skip, wait for dictionary shrink program to run
            if (num && slots > DICT_HT_INITIAL_SIZE &&
                (num*100/slots < 1)) break;
            /* The main collection cycle. Sample random keys among keys
             * with an expire set, checking for expired ones.
             *
             * Sample counter
             */
            // Processed expired key counter
            expired = 0;
            // Total key TTL counter
            ttl_sum = 0;
            // Total processed key counter
            ttl_samples = 0;
            // Can only check at most LOOKUPS_PER_LOOP keys each time
            if (num > ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP)
                num = ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP;
            // Start iterating database
            while (num--) {
                dictEntry *de;
                long long ttl;
                // Randomly get a key with expiration time from expires
                if ((de = dictGetRandomKey(db->expires)) == NULL) break;
                // Calculate TTL
                ttl = dictGetSignedIntegerVal(de)-now;
                // If key has expired, delete it and increment expired counter
                if (activeExpireCycleTryExpire(db,de,now)) expired++;
                if (ttl < 0) ttl = 0;
                // Accumulate key TTL
                ttl_sum += ttl;
                // Accumulate processed key count
                ttl_samples++;
            }
            /* Update the average TTL stats for this database. */
            // Update average TTL statistics for this database
            if (ttl_samples) {
                // Calculate current average
                long long avg_ttl = ttl_sum/ttl_samples;

                // If this is first time setting database average TTL, initialize
                if (db->avg_ttl == 0) db->avg_ttl = avg_ttl;
                /* Smooth the value averaging with the previous one. */
                // Take average of database's last average TTL and this average TTL
                db->avg_ttl = (db->avg_ttl+avg_ttl)/2;
            }
            /* We can't block forever here even if there are many keys to
             * expire. So after a given amount of milliseconds return to the
             * caller waiting for the other active expire cycle. */
            // Can't spend too much time processing expired keys,
            // So this function returns after a certain amount of time
            // Update iteration count
            iteration++;
            // Execute once every 16 iterations
            if ((iteration & 0xf) == 0 && /* check once every 16 iterations. */
                (ustime()-start) > timelimit)
            {
                // If iteration count is exactly a multiple of 16
                // And iteration time exceeded timelimit
                // Then set timelimit_exit
                timelimit_exit = 1;
            }
            // Already timed out, return
            if (timelimit_exit) return;
            /* We don't repeat the cycle if there are less than 25% of keys
             * found expired in the current DB. */
            // If deleted expired keys are 25% of current total database keys with expiration
            // Stop iterating
        } while (expired > ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP/4);
    }
}
```

### AOF, RDB and Replication Handling of Expired Keys

- Generating RDB File
When using SAVE or BGSAVE to generate RDB file, expired keys are not stored

- Loading RDB File
When server exists as master, expired keys are not loaded when loading RDB
When server exists as slave, all keys are loaded

### AOF

Pending.

### Master-Slave Replication

- When master deletes a key, it sends DEL command to all slaves
- When client reads data from slave, even if the key is found to be expired, it's not deleted
- Slaves only accept commands from master
