---
layout: post
title: GDB (with Assembly)
tags: gdb
---

<!-- more -->

## Compile
```bash
gcc -g xxx
```

## Start GDB

```bash
gdb -q ./out
```

or
```bash
gdb -p xxx
```

## Execute

**run**

```
(gdb) run
Starting program: /root/hello
this time is : 1
this time is : 2
this time is : 3
this time is : 4
this time is : 5
this time is : 6
this time is : 7
this time is : 8
this time is : 9
this time is : 10
[Inferior 1 (process 20723) exited with code 01]
Missing separate debuginfos, use: debuginfo-install glibc-2.17-222.el7.x86_64
```

## Show Code

**list**

```
(gdb) list
1       # include<stdio.h>
2
3       int main(void) {
4               char* s = "hello world!";
5               int i=1;
6               for (;i<=10;i++) {
7                       printf("this time is : %d\n", i);
8               }
9
10              return 1;
(gdb)
11      }
(gdb)
Line number 12 out of range; hello.c has 11 lines.
```

## Breakpoint Debugging

**break** **c** **delete**
```
(gdb) break 7
Breakpoint 1 at 0x400536: file hello.c, line 7.
(gdb) run
Starting program: /root/hello

Breakpoint 1, main () at hello.c:7
7                       printf("this time is : %d\n", i);
(gdb) c
Continuing.
this time is : 1

Breakpoint 1, main () at hello.c:7
7                       printf("this time is : %d\n", i);
(gdb) c
Continuing.
this time is : 2

(gdb) delete
Delete all breakpoints? (y or n) y
```

## Print Variable

```
(gdb) print i
$1 = 1
(gdb) display i
2: i = 2
```

## nexti - Execute Next Machine Operation

```bash
(gdb) nexti
5    int i=1;
```

## Disassemble Function (Default AT&T Syntax)

**disassemble (disas)**

```bash
(gdb) disassemble main
Dump of assembler code for function main:
   0x000000000040051d <+0>:     push   %rbp
   0x000000000040051e <+1>:     mov    %rsp,%rbp
   0x0000000000400521 <+4>:     sub    $0x10,%rsp
   0x0000000000400525 <+8>:     movq   $0x4005f0,-0x10(%rbp)
   0x000000000040052d <+16>:    movl   $0x1,-0x4(%rbp)
   0x0000000000400534 <+23>:    jmp    0x40054e <main+49>
=> 0x0000000000400536 <+25>:    mov    -0x4(%rbp),%eax
   0x0000000000400539 <+28>:    mov    %eax,%esi
   0x000000000040053b <+30>:    mov    $0x4005fd,%edi
   0x0000000000400540 <+35>:    mov    $0x0,%eax
   0x0000000000400545 <+40>:    callq  0x400400 <printf@plt>
   0x000000000040054a <+45>:    addl   $0x1,-0x4(%rbp)
   0x000000000040054e <+49>:    cmpl   $0xa,-0x4(%rbp)
   0x0000000000400552 <+53>:    jle    0x400536 <main+25>
   0x0000000000400554 <+55>:    mov    $0x1,%eax
   0x0000000000400559 <+60>:    leaveq
   0x000000000040055a <+61>:    retq
End of assembler dump.
```

## Disassembly Function (Intel Syntax)

**disassembly (disas)**

```
(gdb) set disassembly-flavor intel
(gdb) disassemble main
Dump of assembler code for function main:
   0x000000000040051d <+0>:     push   rbp
   0x000000000040051e <+1>:     mov    rbp,rsp
   0x0000000000400521 <+4>:     sub    rsp,0x10
   0x0000000000400525 <+8>:     mov    QWORD PTR [rbp-0x10],0x4005f0
   0x000000000040052d <+16>:    mov    DWORD PTR [rbp-0x4],0x1
   0x0000000000400534 <+23>:    jmp    0x40054e <main+49>
=> 0x0000000000400536 <+25>:    mov    eax,DWORD PTR [rbp-0x4]
   0x0000000000400539 <+28>:    mov    esi,eax
   0x000000000040053b <+30>:    mov    edi,0x4005fd
   0x0000000000400540 <+35>:    mov    eax,0x0
   0x0000000000400545 <+40>:    call   0x400400 <printf@plt>
   0x000000000040054a <+45>:    add    DWORD PTR [rbp-0x4],0x1
   0x000000000040054e <+49>:    cmp    DWORD PTR [rbp-0x4],0xa
   0x0000000000400552 <+53>:    jle    0x400536 <main+25>
   0x0000000000400554 <+55>:    mov    eax,0x1
   0x0000000000400559 <+60>:    leave
   0x000000000040055a <+61>:    ret
End of assembler dump.
```

Obviously, Intel syntax is more human-readable.

The above is filled with various assembly instructions and some registers:

**mov**: move, copy values from one place to another.
**jmp**: jump, CPU switch context.
**call**: subroutine
**jle**: if <= then jump
**ret**: return from subroutine
**cmp**: compare


## Show Registers

```bash
(gdb) info register
rax            0x11     17
rbx            0x0      0
rcx            0x10     16
rdx            0x7ffff7dd6a00   140737351870976
rsi            0x7fffffef       2147483631
rdi            0x0      0
rbp            0x7fffffffe320   0x7fffffffe320
rsp            0x7fffffffe310   0x7fffffffe310
r8             0x0      0
r9             0x7ffff7a5b16d   140737348219245
r10            0x22     34
r11            0x246    582
r12            0x400430 4195376
r13            0x7fffffffe400   140737488348160
r14            0x0      0
r15            0x0      0
rip            0x400536 0x400536 <main+25>
eflags         0x297    [ CF PF AF SF IF ]
cs             0x33     51
ss             0x2b     43
ds             0x0      0
es             0x0      0
fs             0x0      0
gs             0x0      0
(gdb)
```

Or brief command:

```bash
(gdb) i r rax
rax            0x11     17
```


## What Do the Registers Do?

```bash
(gdb) disassemble main
Dump of assembler code for function main:
0x000000000040051d <+0>:     push   rbp
0x000000000040051e <+1>:     mov    rbp,rsp
0x0000000000400521 <+4>:     sub    rsp,0x10
0x0000000000400525 <+8>:     mov    QWORD PTR [rbp-0x10],0x4005f0
0x000000000040052d <+16>:    mov    DWORD PTR [rbp-0x4],0x1
0x0000000000400534 <+23>:    jmp    0x40054e <main+49>
0x0000000000400536 <+25>:    mov    eax,DWORD PTR [rbp-0x4]
0x0000000000400539 <+28>:    mov    esi,eax
0x000000000040053b <+30>:    mov    edi,0x4005fd
0x0000000000400540 <+35>:    mov    eax,0x0
0x0000000000400545 <+40>:    call   0x400400 <printf@plt>
0x000000000040054a <+45>:    add    DWORD PTR [rbp-0x4],0x1
0x000000000040054e <+49>:    cmp    DWORD PTR [rbp-0x4],0xa
0x0000000000400552 <+53>:    jle    0x400536 <main+25>
0x0000000000400554 <+55>:    mov    eax,0x1
0x0000000000400559 <+60>:    leave
0x000000000040055a <+61>:    ret
```

- **push rbp**: rbp will be the starting stack address of main(). The rsp (stack pointer) register tells us where the top of the stack currently is.
- **First 3 instructions**: Will create a **Call Stack Frame**
- ESI/EDI are called "Source/Destination Index registers" respectively. In many string operation instructions, DS:ESI points to the source string, while ES:EDI points to the destination string. As shown below, **edi** stores the "this time is : %d\n" in printf, while esi stores the value i of **%d** for this iteration.
```bash
(gdb) i r eax esi edi
eax            0x2      2
esi            0x2      2
edi            0x4005fd 4195837
(gdb) x/ls 0x4005fd
0x4005fd:       "this time is : %d\n"
```

- **mov esi,eax**: EAX is the "accumulator" and is the default register for many addition and multiplication instructions. So after the loop ends, **mov eax,0x1** eax performs accumulation, then does the **esi=eax** operation

- **mov edi,0x4005fd**: Because the address 0x4005fd stores our constant string `this time is: %d\n`, the edi register points to this address in this iteration.

- **jle 0x400536 <main+25>**: If the condition is still met, jump back to the loop start position


# Cheatsheet

![http://img.xuwenzhi.com/gdb-cheatsheet1.png](http://img.xuwenzhi.com/gdb-cheatsheet1.png)

![http://img.xuwenzhi.com/gdb-cheatsheet2.png](http://img.xuwenzhi.com/gdb-cheatsheet2.png)


# Reference

[What do eax, ebx, ecx, edx, esi, edi, ebp, esp mean in assembly language?](https://blog.csdn.net/lincyang/article/details/5441066)

[debugging with gdb part 1](https://suchprogramming.com/debugging-with-gdb-part-1/)

[Comparing C to machine language](https://www.youtube.com/watch?v=yOyaJXpAYZQ)
