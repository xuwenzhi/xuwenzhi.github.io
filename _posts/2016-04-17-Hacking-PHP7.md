---
layout: post
title: Hacking PHP7
tags: php php-internals
---

If you're learning about PHP internals, this process can be quite tedious, and I bet you don't know where to start. This article will give you a great roadmap!

<!-- more -->

## Prerequisites

- A copy of PHP source code
- A working Linux environment
- Don't get too deep at first; quickly go through the process once

## PHP7 Code Execution Flow

The reason we're talking about PHP7 specifically is that PHP7 has significant changes, so it differs slightly from previous versions. If you want to learn about the code execution flow of earlier PHP versions, you can check out [Deep Understanding of PHP Code Execution Process](http://c.colabug.com/thread-1024603-1-1.html)

![PHP5 Code Execution Flow](http://img.xuwenzhi.com/php-code-execute-process.png?zoom=2&resize=710%2C394)

This diagram shows the PHP5 code execution flow. The reason I mention this is that PHP7's code execution flow is slightly different. PHP7 added an extra step called Abstract Syntax Tree (AST) (see [What is an Abstract Syntax Tree](https://www.jianshu.com/p/8fa61a552ecf)). So where exactly is this step added? It's after Parsing (syntax analysis) and before compilation. For the question of whether adding this step slows down PHP7 program execution, you can refer to [Changes Brought by PHP7's Abstract Syntax Tree (AST)](https://www.tuicool.com/articles/iYJNB3V).

![PHP7 Code Execution Flow](http://img.xuwenzhi.com/php7_code_execute.png?zoom=2&resize=710%2C238)

---

Now that we have a general understanding of PHP7 execution, let's dive into the PHP7 internals. In this example, we'll implement a new function within the internals that basically has the same functionality as the print() function. Although the functionality is simple, it's very meaningful for understanding PHP7 internals.

Final Result:

{% highlight bash %}
./sapi/cli/php -r "echo hackphp('hacking PHP7');"
{% endhighlight %}

### Constructing the Lexical Analysis Fragment

Edit the Zend/zend_language_scanner.l file. In this file, you'll find many variables starting with T_. You can try searching for T_IF, T_ECHO, or T_INCLUDE. It's not hard to imagine that this file defines the keyword fragments commonly used in PHP. For example, if you use an if statement in PHP code, the lexical analyzer will map it to T_IF, preparing for the next step of syntax analysis. Let me stop here; add code at the following position (only add the code between //...start and //...end; the same applies later):

{% highlight c %}
<ST_IN_SCRIPTING>"else" {
RETURN_TOKEN(T_ELSE);
}
//...start
<ST_IN_SCRIPTING>"hackphp" {
RETURN_TOKEN(T_HACKPHP);
}
//...end
<ST_IN_SCRIPTING>"while" {
RETURN_TOKEN(T_WHILE);
}
{% endhighlight %}

### Constructing Syntax Expressions

Edit Zend/zend_language_parser.y. In this file, you can also find variables like T_IF. This file will construct some expressions and syntax parsing rules for our hackphp() function, preparing for the next step of generating the syntax tree!

{% highlight c %}
%token T_INCLUDE "include (T_INCLUDE)"
//...start
%token T_HACKPHP "hackphp (T_HACKPHP)"
//...end
%token T_INCLUDE_ONCE "include_once (T_INCLUDE_ONCE)"

//...omitted

%left '&'
//...start
%nonassoc T_HACKPHP
//...end
%nonassoc T_IS_EQUAL T_IS_NOT_EQUAL T_IS_IDENTICAL T_IS_NOT_IDENTICAL T_SPACESHIP

//...omitted

    |   T_STATIC function returns_ref backup_doc_comment '(' parameter_list ')' lexical_vars
        return_type '{' inner_statement_list '}'
            { $$ = zend_ast_create_decl(ZEND_AST_CLOSURE, $3 | ZEND_ACC_STATIC, $2, $4,
                  zend_string_init("{closure}", sizeof("{closure}") - 1, 0),
                  $6, $8, $11, $9); }

//...start
| T_HACKPHP '(' expr ')' { $$ = zend_ast_create(ZEND_AST_HACKPHP, $3); }
//...end
;

function:
T_FUNCTION { $$ = CG(zend_lineno); }
;
{% endhighlight %}

### 3. Notify AST to Parse Our hackphp() Function

Edit Zend/zend_ast.h, and add to the enum variable \_zend_ast_kind:

{% highlight c %}
ZEND_AST_CONTINUE,
//...start
ZEND_AST_HACKPHP,
//...end
{% endhighlight %}

### 4. Notify Zend VM to Compile Our hackphp() Function

Next, we'll notify the Zend VM to compile our hackphp(). Edit the Zend/zend_compile.c file. First, find the zend_compile_expr() function and add a case for ZEND_AST_HACKPHP:

{% highlight c %}
//...omitted
case ZEND_AST_CLOSURE:
zend_compile_func_decl(result, ast);
return;
//...start
case ZEND_AST_HACKPHP:
 zend_compile_hackphp(result, ast);
 return;
//...end
default:
ZEND_ASSERT(0 /* not supported */);
}
}
{% endhighlight %}

Then define the zend_compile_hackphp() function below zend_compile_expr():

{% highlight c %}
void zend_compile_hackphp(znode *result, zend_ast *ast)
{
zend_ast *expr_ast = ast->child[0];
znode expr_node;
zend_compile_expr(&expr_node, expr_ast);
zend_emit_op(result, ZEND_HACKPHP, &expr_node, NULL);
}
{% endhighlight %}

### 5. Let Zend VM Recognize and Execute the OPCODE Generated by hackphp()

Edit the Zend/zend_vm_def.h file. My suggestion is to first navigate to the bottom of the file, then add the following function:

{% highlight c %}
ZEND_VM_HANDLER(184, ZEND_HACKPHP, ANY, ANY)
{
 USE_OPLINE
 zend_free_op free_op1;
 zval *op1;

SAVE_OPLINE();
 op1 = GET_OP1_ZVAL_PTR_UNDEF(BP_VAR_R);

if (Z_TYPE_P(op1) != IS_STRING) {
 zend_throw_exception_ex(NULL, 0,
 "hackphp expects a string !");
 HANDLE_EXCEPTION();
 }
 ZVAL_COPY(EX_VAR(opline->result.var), op1);

FREE_OP1();
 ZEND_VM_NEXT_OPCODE_CHECK_EXCEPTION();
}
{% endhighlight %}

If you've made it this far, it means we've added all the necessary code. If you noticed, the order of code processing follows exactly the PHP7 code execution order, which reinforces your understanding of the PHP code execution flow. Now, let's test whether our hackphp() function works properly!

### Compiling PHP7

Compile PHP7 in the following order. If you get errors, review the steps above to see if you missed anything:

{% highlight c %}
./buildconf
./configure
make
{% endhighlight %}

## Verifying hackphp()

{% highlight c %}
./sapi/cli/php -r "echo hackphp('hacking PHP7!');"
{% endhighlight %}

# Conclusion

If you see "hacking PHP7!" output, congratulations! You've now understood the PHP code execution flow and learned some very important knowledge about PHP7 internals. Thinking about it, there are definitely gains from this. Through this experiment, I believe you may now have an answer to how to learn PHP internals and read PHP source code.
